
//*************************************************************************************************
//
// Управление кольцевым буфером
//
//*************************************************************************************************

#include <stdio.h>
#include <string.h>
#include <stdbool.h>

#include "cmsis_os2.h"

#include "uart.h"
#include "ring_uart.h"
#include "events.h"

//****************************************************************************************************************
// Локальные константы
//****************************************************************************************************************
#define RING_SIZE       2048        //размер кольцевого буфера

//****************************************************************************************************************
// Прототипы локальных функций
//****************************************************************************************************************
static void RingAddChar( char ch );

//****************************************************************************************************************
// Локальные переменные
//****************************************************************************************************************
typedef struct {
    uint16_t head;                  //указатель на голову
    uint16_t tail;                  //указатель на хвост
    char buffer[RING_SIZE];         //данные
 } RING_UART;

RING_UART SendUart;

//****************************************************************************************************************
// Обнуление указателей в кольцевом буфере
//****************************************************************************************************************
void RingClear( void ) {

    SendUart.head = 0;
    SendUart.tail = 0;
 }

//****************************************************************************************************************
// Добавление строки в кольцевой буфер
// uint8_t *str - адрес строки для добавления в буфер
//****************************************************************************************************************
void RingAddStr( char *str ) {

    uint16_t len, ind;

    len = strlen( str );
    //добавление данных буфер
    for ( ind = 0; ind < len; ind++ )
        RingAddChar( *str++ );
    //запуск передачи
    UARTSendStart();
 }

//****************************************************************************************************************
// Добавление строки в кольцевой буфер
// uint8_t *str - адрес строки для добавления в буфер
// uint16_t len - кол-во символов для добавления
//****************************************************************************************************************
void RingAddStrLen( char *str, uint16_t len ) {

    uint16_t ind;

    for ( ind = 0; ind < len; ind++ )
        RingAddChar( *str++ );
    //запуск передачи
    UARTSendStart();
 }

//****************************************************************************************************************
// Добавление одного символа в кольцевой буфер
// uint8_t ch - добавляемый символ
//****************************************************************************************************************
static void RingAddChar( char ch ) {

    SendUart.buffer[SendUart.tail++] = ch;
    if ( SendUart.tail >= sizeof( SendUart.buffer ) )
        SendUart.tail = 0; //вышли за пределы буфера, переходим в начало
 }

//****************************************************************************************************************
// Прочитать один байт из кольцевого буфера
// uint8_t *ptr   - указатель на переменную, куда будет помещен прочитанный байт
// return = true  - байт прочитан
//        = false - данных нет
//****************************************************************************************************************
bool RingGetChar( char *ch ) {

    if ( !RingGetCount() )
        return false;
    *ch = SendUart.buffer[SendUart.head];
    SendUart.head++;
    if ( SendUart.head == sizeof( SendUart.buffer ) )
        SendUart.head = 0;
    return true;
 }

//****************************************************************************************************************
// Возвращает кол-во элементов в кольцевом буфере готовых для чтения (передачи в UART)
// return uint16_t - кол-во в байтах
//****************************************************************************************************************
uint16_t RingGetCount( void ) {

    if ( SendUart.head == SendUart.tail )
        return 0;
    if ( SendUart.tail < SendUart.head )
        return sizeof( SendUart.buffer ) + SendUart.tail - SendUart.head;
    else return SendUart.tail - SendUart.head;
 }

//****************************************************************************************************************
// Возвращает общий размер кольцевого буфера
// return uint16_t - кол-во в байтах
//****************************************************************************************************************
uint16_t RingGetSize( void ) {

    return sizeof( SendUart.buffer );
 }

//****************************************************************************************************************
// Проверяет возможность размещения данных в кольцевом буфере
// uint16_t size  - размер данных в байтах
// return = true  - есть место для размещения
//        = false - места нет, выполняем захват семафора пока буфер не будет освобожден      
//****************************************************************************************************************
bool RingGetAdd( uint16_t size ) {

    if ( size < RingGetFree() )
        return true; //есть место для размещения
    else {
        //захват семафора
        osSemaphoreAcquire( sem_wait, 0 );
        return false;
       }
 }

//****************************************************************************************************************
// Проверяем свободное место в буфере. Вызов из CallBackUsart()
// При наполненности < 10% снимаем семафор
//****************************************************************************************************************
void RingCheckFree( void ) {

    if ( sem_wait == NULL )
        return;
    if ( RingGetUsed() < 10 )
        osSemaphoreRelease( sem_wait );
 }

//****************************************************************************************************************
// Кол-во свободного места в кольцевом буфере
// return - размер в байтах
//****************************************************************************************************************
uint16_t RingGetFree( void ) {

    return sizeof( SendUart.buffer ) - RingGetCount();
 }

//****************************************************************************************************************
// Возвращает уровень заполнения кольцевого буфера в процентах 0 - 100%
// return - размер в процентах
//****************************************************************************************************************
uint8_t RingGetUsed( void ) {

    return (uint8_t)( ( (float)RingGetCount()/(float)sizeof( SendUart.buffer ) ) * 100 ) ;
 }

//****************************************************************************************************************
//
//****************************************************************************************************************
void RingPtr( uint16_t *head, uint16_t *tail ) {

    *head = SendUart.head;
    *tail = SendUart.tail;
 }

